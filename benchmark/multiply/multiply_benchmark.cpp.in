#include <benchmark/benchmark.h>

#include "REPEAT.hpp"

// clang-format off
#include "${MULTIPLIER_HEADER}"
#define ${MULTIPLIER_TYPE}
#ifdef CUDA_MULTIPLIER
#include "multiply/cuda_multiply.cuh"
#endif

static void BM_${MULTIPLIER}(benchmark::State& state) {
  auto multiply = ${MULTIPLIER}{};
  auto const N = state.range(0);
  auto const a = [N] {
    auto v = std::vector<double>(N);
    for (auto i = 0; auto& x : v) {
      x = static_cast<double>(i++) / static_cast<double>(N);
    }
    return v;
  }();
  auto const b = a;
  auto c = std::vector<double>(N);

#ifdef CUDA_MULTIPLIER
  cuda_multiply_host_data(
      [&](std::size_t n, double const* dev_a, double const* dev_b,
          double* dev_c) {
        for (auto _ : state) {
          REPEAT({
            multiply(n, dev_a, dev_b, dev_c);
          });
          cudaDeviceSynchronize();
        }
      },
      N, a.data(), b.data(), c.data());
#else
  for (auto _ : state) {
    REPEAT({
      auto result_ptr = c.data();
      multiply(N, a.data(), b.data(), c.data());
      benchmark::DoNotOptimize(result_ptr);
      benchmark::ClobberMemory();
    });
  }
#endif

  state.SetItemsProcessed(state.iterations() * N * N_REPEAT);
}

BENCHMARK(BM_${MULTIPLIER})
    ->MeasureProcessCPUTime()
    ->UseRealTime()
    ->RangeMultiplier(2)
    ->Range(1 << 5, 1 << 28);
// clang-format on
